<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>El Futuro de las Promesas</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/vs.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal promises">
			<div class="slides">
				<section>
					<h1>El Futuro de las Promesas</h1>
					<p>Carlos Molina A.</p>
					<span>12 de octubre 2018</span>
				</section>
				<section>
					<h3>Carlos Molina</h3>
					<p>Desarrollador de software en Kunder</p>
					<p>Previamente en Heartlytics (telemedicina), y NIU Sushi (delivery comida)</p>
					<div class="row">
						<img src="img/image1.jpg" alt="Dani, Horacio y yo">
						<img src="img/image2.png" alt="Punto">
					</div>

				</section>
				<section>
					<h3>Debemos aprender r치pido!</h3>
					<p>"Experto"</p>
					<p>Buscamos patrones</p>
					<p class="fragment fade-in">En ocasiones, debemos desaprender</p>
					<aside class="notes">
						Cliente pide, estudiamos una cantidad finita de tiempo.<br>
						Te conviertes en "experto"<br>
						Buscamos replicar lo que sabemos funcion칩 en el pasado. 춰Y est치 muy bien!<br>
						쯈ui칠n tiene tiempo para eso? Tenemos que entregar. Y terminamos entregando cosas de este estilo.
					</aside>
				</section>
				<section>
					<h2>1. Pir치mide de la perdici칩n</h2>
					<pre><code data-trim>
											// uses promises as callbacks 游눨
											remotedb.allDocs({ include_docs: true })
											.then(function(result) {
												const docs = result.rows;
												docs.forEach(function(element) {
														localdb.put(element.doc).then(function(response) {
															alert("Pulled doc with id " + element.doc._id + ", added to local db.");
														}).catch(function (err) {
															if (err.name == 'conflict') {
																localdb.get(element.doc._id).then(function (resp) {
																	localdb.remove(resp._id, resp._rev).then(function (resp) {
											// etc, etc, etc...
										</code></pre>
					<aside class="notes">
						쯅otan la forma piramidal? Tambi칠n se le llama "callback-hell", a pesar de que no son callbacks.<br>
						Las promesas, promet칤an, no tener este problema.<br>
						Es dificil entender d칩nde est치s, y cu치l es la siguiente l칤nea a ejecutar.
					</aside>
				</section>
				<section>
					<h2>2. Side effects</h2>
					<pre><code data-trim>
											somePromise().then(() => {
												someOtherPromise();
											})
											.then(() => {
												// I hope "someOtherPromise" has resolved! 游땒
												// Spoiler alert: it hasn't. 游땓
											});
										</code></pre>
					<aside class="notes">
						쮺칩mo tener claridad de que la l칤nea anterior ya se ha completado?
					</aside>
				</section>
				<section>
					<h3>쯉abes cu치l es la diferencia?</h3>
					<pre><code data-trim>
										doSomething().then(function () {
											return doSomethingElse();
										}); // 1

										doSomething().then(function () {
											doSomethingElse();
										}); // 2

										doSomething().then(doSomethingElse() ); // 3

										doSomething().then(doSomethingElse ); // 4
									</code></pre>
				</section>
				<section>
					<h2>Idea: Entender c칩mo fueron pensadas las Promesas</h2>
					<ol>
						<li>JavaScript</li>
						<li>Sync vs Async</li>
					</ol>
					<aside class="notes">
						Entender qu칠 son las Promesas, c칩mo se pens칩 se usar칤an, y c칩mo resolver el 80% de los problemas m치s comunes con un 칰nico truco.<br>
						JavaScript, es un lenguaje de un 칰nico hilo. Muy conveniente para manejar grandes cantidades de eventos.<br>
						Operaci칩n s칤ncrona: se ejecuta en el hilo principal de ejecuci칩n. Ej: Operaciones matem치ticas, manejo de strings.<br>
						Operaci칩n as칤ncronas: se ejecuta en fuera del hilo principal. Esperamos un evento para cuando esten listas. Ej: descargar, guardar archivo.
					</aside>
				</section>
				<section>
					<h3>sync vs callback async</h3>
					<pre><code data-trim>
										// sync
										try {
											const user = getUser();
											console.log('Hello ' + user.name);
										} catch(err) {
											console.error(err);
										}
									</code></pre>
					<pre class="fragment fade-in"><code data-trim>
										// callback async
										getUser(function (err, user) {
											if (!!err) {
												return console.error(err);
											}
											console.log('Hello ' + user.name);
										});
									</code></pre>
					<aside class="notes">
						Es muy complicado. Y es s칩lo llamar a una funci칩n as칤ncrona.<br>
						Imagina el manejo de errores.<br>
						Aqu칤 nace el t칤pico c칩digo piramidal, o callback hell.
					</aside>
				</section>
				<section>
					<h3>sync vs Promise async</h3>
					<pre><code data-trim>
														// sync
														try {
															const user = getUser();
															console.log('Hello ' + user.name);
														} catch(err) {
															console.error(err);
														}
													</code></pre>
					<pre class="fragment fade-in"><code data-trim>
														// Promise async
														getUser()
														.then(user => {
															console.log('Hello ' + user.name);
														})
														.catch((err) => console.error(err));
													</code></pre>
					<aside class="notes">
						Es m치s similar al c칩digo s칤ncrono.<br>
						El c칩digo se vuelve procedural<br>
						Manejo de errores es similar a un try/catch.
					</aside>
				</section>
				<section>
					<h1>2 trucos fundamentales</h1>
				</section>
				<section>
					<h2>1. Pir치mide de la perdici칩n</h2>
					<pre><code data-trim>
						// uses promises as callbacks 游눨
						remotedb.allDocs({ include_docs: true })
						.then(function(result) {
							const docs = result.rows;
							docs.forEach(function(element) {
									localdb.put(element.doc).then(function(response) {
										alert("Pulled doc with id " + element.doc._id + ", added to local db.");
									}).catch(function (err) {
										if (err.name == 'conflict') {
											localdb.get(element.doc._id).then(function (resp) {
												localdb.remove(resp._id, resp._rev).then(function (resp) {
						// etc, etc, etc...
					</code></pre>
					<aside class="notes">
						Recuerdan la pir치mide de la perdici칩n?<br>
						En lugar de poner un `.then` dentro de una Promesa, **retorna una promesa**.
					</aside>
				</section>
				<section>
					<h2>1. Pir치mide de la perdici칩n</h2>
					<pre><code data-trim>
						// chain promises 游뚝游뚞游뚞游뚞
						remotedb.allDocs({ include_docs: true })
						.then(allDocs => localdb.put(...) )
						.then(resultOfPut => localdb.get(...) )
						.then(resultOfGet => localdb.put(...) )
						.catch(err => console.error(err) );
					</code></pre>
					<h3 class="fragment fade-in">Truco F.1: Encadena las promesas</h3>
					<aside class="notes">
						Las promesas fueron pensadas para ser encadenadas.
					</aside>
				</section>
				<section>
					<h2>2. Evita los side effects</h2>
					<pre><code data-trim>
						somePromise().then(() => {
							someOtherPromise();
						})
						.then(() => {
							// I hope "someOtherPromise" has resolved! 游땒
							// Spoiler alert: it hasn't. 游땓
						});
					</code></pre>
					<aside class="notes">
						쮺칩mo estar seguros de que la "someOtherPromise" ha terminado?
					</aside>
				</section>
				<section>
					<h2>2. Evita los side effects</h2>
					<pre><code data-trim>
						somePromise().then(() => {
							return someOtherPromise();  // return!
						})
						.then(result => {
							// "someOtherPromise" has resolved! 游땒
							// I also has its result
						});
					</code></pre>
					<h3 class="fragment fade-in">Truco F.2: Retorna. Siempre retorna</h3>
					<aside class="notes">
						"somePromise" se ejecuta. Cuando est칠 listo, retornar치 "someOtherPromise".<br>
						Y cuando esta 칰ltima promesa est칠 lista, se llamar치 el siguiente bloque `.then`.<br>
						Moraleja: Siempre retorna. Ya sea un valor s칤ncrono o as칤ncrono, siempre retorna.
					</aside>
				</section>
				<section>
					<h1>3 trucos avanzados</h1>
				</section>
				<section>
					<h2>1. 쮺칩mo crear una Promesa?</h2>
					<pre><code data-trim>
						// sync
						Promise.resolve(42);
						Promise.reject(new Error('Bad parameter'));

						// async
						new Promise((resolve, reject) => {
							fs.readFile('myfile.txt', (err, file) => {
								if (err) {
									return reject(err);
								}
								resolve(file);
							});
						});
					</code></pre>
					<p><strong>Nunca uses deferred</strong>.</p>
					<h3 class="fragment fade-in">Truco A.1: Promise.resolve, Promise.reject o new Promise()</h3>
					<aside class="notes">
						Si ves defer en el c칩digo, seguro lo puedes reemplazar por alguna de estas opciones.
					</aside>
				</section>
				<section>
					<h2>2. 쮺칩mo correr una lista de promesas en paralelo?</h2>
					<pre><code data-trim>
						// I want to remove() all docs
						db.allDocs({include_docs: true})
						.then(result => {
							result.rows.forEach(row => {
								db.remove(row.doc);
							});
						})
						.then(() => {
							// I naively believe all docs have been removed() now! 游눨
						});
					</code></pre>
					<aside class="notes">
						쮺u치l es el problema de este c칩digo?<br>
						Olvidaste retornar.<br>
						Debes esperar que toda una lista de Promesas resuelva. `Promise.all`.
					</aside>
				</section>
				<section>
					<h2>2. 쮺칩mo correr una lista de promesas en paralelo?</h2>
					<pre><code data-trim>
						// I want to remove() all docs
						db.allDocs({include_docs: true})
						.then(result => {
							const removePromises = result.rows.map(row => {
								return db.remove(row.doc);
							};
							return Promise.all(removePromises);
						})
						.then(arrayOfResults => {
							// All docs have really been removed() now!
						});
					</code></pre>
					<h3 class="fragment fade-in">Truco A.2: Retorna Promise.all con una lista</h3>
					<aside class="notes">
						Promise.all recibe un arreglo con promesas, y retorna una promesa que s칩lo resuelve cuando cada una de sus promesas
						recibidas ha resuelto.
						Promise.all es el equivalente as칤ncrono de un for-loop.

						Adem치s, Promise.all retorna un arreglo con el resultado de cada promesa a la siguiente funci칩n, lo cu치l es muy
						conveniente.
						Promise.all queda como rejected, o falla, si es que cualquiera de sus sub-promesas falla. Muy 칰til.
					</aside>
				</section>
				<section>
					<h2>3. Unhappy-path Driven Development</h2>
					<pre><code data-trim>
						somePromise()
						.then(() => anotherPromise() )
						.then(() => yetAnotherPromise() )
						.catch(err => console.error(err) ); // <-- badass
					</code></pre>
					<h3 class="fragment fade-in">Truco A.3: Maneja tus errores</h3>
					<aside class="notes">
						Siempre parte programando los casos borde, los errores. Despu칠s se te va a olvidar.<br>
						Los programadores somos muy confiados y se nos olvida poner el .catch()<br>
						Cualquier error en la ejecuci칩n de tu programa ser치 desaparecido. Esto si es duro de debbuggear.<br>
					</aside>
				</section>
				<section>
					<h3>Ahora 쯥abes cu치l es la diferencia?</h3>
					<pre><code data-trim>
						return doSomething().then(function () {
							return doSomethingElse();
						}).then(finalHandler); // 1

						return doSomething().then(function () {
							doSomethingElse();
						}).then(finalHandler); // 2

						return doSomething()
						.then(doSomethingElse() )
						.then(finalHandler); // 3

						return doSomething()
						.then(doSomethingElse)
						.then(finalHandler); // 4
					</code></pre>
					<aside class="notes">
						Ahora, 쯥aben la diferencia?<br>
						1. ---doSomething--- ---doSomethingElse--- ---finalHandler---.
						2. ---doSomething---
								---doSomethingElse---
																---finalHandler---.
						3. ---doSomething---
							 ---doSomethingElse(undefined)---
																---finalHandler---.
						4. ---doSomething--- ---doSomethingElse(r)--- ---finalHandler---.
					</aside>
				</section>
				<section>
					<h1>El Futuro de las Promesas</h1>
					<aside class="notes">
						쮿an escuchado de async/await? Apareci칩 en C++ como corutinas, y en .NET con C# y F# en la primera d칠cada del 2000.<br>
						쮺칩mo podemos hacer que c칩digo as칤ncrono se vea m치s similar al c칩digo s칤ncrono?
					</aside>
				</section>
				<section>
					<h3>sync vs async/await</h3>
					<pre><code data-trim>
						// sync
						function printAndReturnName() {
							try {
								const user = getUser();
								console.log('Hello ' + user.name);
								return user.name;
							} catch(err) {
								console.error(err);
							}
						}
					</code></pre>
					<pre class="fragment fade-in"><code data-trim>
						// async/await 游땙
						async function printAndReturnName() {
							try {
								const user = await getUser();
								console.log('Hello ' + user.name);
								return user.name;
							} catch(err) {
								console.error(err);
							}
						}
					</code></pre>
					<aside class="notes">
						쯅otan la diferencia?<br>
						Funci칩n debe llevar el keyword `async`, que indica el resultado de la funci칩n siempre ser치 una promesa.<br>
						Usa el keyword `await` para esperar que una promesa se resuelva. Luego cont칤nua con tu c칩digo :)
					</aside>
				</section>
				<section>
					<img src="img/async-support.png">
					<aside class="notes">
						85% de la poblaci칩n global lo soporta.<br>
						En Chile, 92%<br>
						Igual puedes usar un transpilador, como Babel o TypeScript, que se encargan de que funcione en todos los dispositivos del cliente.
					</aside>
				</section>
				<section>
					<h1>Resumen</h1>
					<aside class="notes">
						Si queremos realmente entender una tecnolog칤a, debemos dejar ciertos h치bitos atr치s.<br>
						Dedicarle tiempo.<br>
						Pero, 쯣or qu칠?<br>
						쯈u칠 pasar칤a si us치ramos las tecnolog칤as de la forma en que fueron dise침adas?<br>
						Menos horas debuggeando. Menos proyectos que nadie quiere trabajar en ellos.<br>
						C칩digos en que de gusto llegar a trabajar.<br>
						Y esta idea es algo que creo vale la pena intentar. Muchas gracias.
					</aside>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
